{
    "input output redirection" : {
        "prefix": "online_judge",
        "body": [
            "#ifdef dark_angel",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "#endif",
        ]
    },
    "fast Input output" : {
        "prefix": "fast io",
        "body": "#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL);"
    },
    "printing macros": {
        "prefix": "debugger",
        "body": [
          "#define deb(x) cout << #x << \"->\" << x << endl;",
          "#define print(x) for(auto &x_:x) cout << x_ << \" \"; cout << endl;"
        ],
        "description": "printing macros"
    },
    "main cp template" : {
        "prefix": "cp_1_template",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "",
            "#define int long long",
            "#define endl \"\\n\"",
            "#define deb(x) cout << #x << \" -> \"  << x << endl;",
            "#define print(x) for(auto x_:x) cout << x << \" \"; cout << endl;",
            "#define pb push_back",
            "#define all(x) x.begin(), x.end()",
            "#define prec(x, y) fixed << setprecision(y) << x",
            "",
            "void solve() {",
                "\tint i, j, n, m, k, ans;",
            "    $2",
            "}",
            "",
            "int32_t main() {",
            "#ifdef dark_angel",
                "\tfreopen(\"input.txt\", \"r\", stdin);",
                "\tfreopen(\"output.txt\", \"w\", stdout);",
            "#endif",
                "\tios::sync_with_stdio(0);",
                "\tcout.tie(0);",
                "\tcin.tie(0);",
            "",
                "\tint tc=1;",
                "\t$1// cin >> tc;",
                "\twhile(tc--) {",
            "\t\tsolve();",
                "\t}",
            "}",
        ]
    },
    "regular tree template": {
        "prefix": "dsa_tree_1",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "#define deb(x) cout << #x << \" -> \" << x << endl;",
          "",
          "struct node {",
          "    int data;",
          "    node *left;",
          "    node *right;",
          "};",
          "",
          "node *newNode(int key) {",
          "    node *temporary = new node;",
          "    // temporary -> data = 0;",
          "    temporary->left = NULL;",
          "    temporary->right = NULL;",
          "    return temporary;",
          "}",
          "",
          "${2}",
          "",
          "int main() {",
          "    ${1}",
          "    return 0;",
          "}"
        ],
        "description": "regular tree template"
      },
      "tree template with struct contructor": {
        "prefix": "dsa_tree_2",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "#define deb(x) cout << #x << \" -> \" << x << endl;",
          "",
          "struct node {",
          "    int data;",
          "    node *left;",
          "    node *right;",
          "",
          "    node() {",
          "        left = NULL;",
          "        right = NULL;",
          "    }",
          "",
          "    node(int data_) {",
          "        data = data_;",
          "        left = NULL;",
          "        right = NULL;",
          "    }",
          "};",
          "",
          "${2}",
          "",
          "int main() {",
          "    ${1}",
          "    return 0;",
          "}"
        ],
        "description": "tree template with struct contructor"
      },
      "sample tree using all cases": {
        "prefix": "sample_tree_1",
        "body": [
          "node *root = newNode(50);",
          "root->left = newNode(25);",
          "root->right = newNode(75);",
          "root->left->left = newNode(12);",
          "root->left->right = newNode(37);",
          "root->left->right->left = newNode(30);",
          "root->right->left = newNode(62);",
          "root->right->right = newNode(87);",
          "root->right->left->right = newNode(70);"
        ],
        "description": "sample tree using all cases"
      },
      "sample tree using all cases node constructor": {
        "prefix": "sample_tree_2",
        "body": [
          "node *root = new node(50);",
          "root->left = new node(25);",
          "root->right = new node(75);",
          "root->left->left = new node(12);",
          "root->left->right = new node(37);",
          "root->left->right->left = new node(30);",
          "root->right->left = new node(62);",
          "root->right->right = new node(87);",
          "root->right->left->right = new node(70);"
        ],
        "description": "sample tree using all cases node constructor"
      },


      // pepcoding templates
      "Pep Coding Template for Trees (Foundation Class) construct from inorder and display like it is": {
        "prefix": "pep_found_tree",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "",
          "struct node {",
          "    int data;",
          "    node *left;",
          "    node *right;",
          "",
          "    node(int data, node *left, node *right) {",
          "        this->data = data;",
          "        this->left = left;",
          "        this->right = right;",
          "    }",
          "};",
          "",
          "class Pair {",
          "   public:",
          "    node *root;",
          "    int state;",
          "",
          "    Pair(node *root, int state) {",
          "        this->root = root;",
          "        this->state = state;",
          "    }",
          "};",
          "",
          "void display(node *root);",
          "node *construct();",
          "",
          "/* -------------------------------- main code ------------------------------- */",
          "$1",
          "/* ------------------------------ main function ----------------------------- */",
          "int main() {",
          "    node *root = construct();",
          "",
          "    display(root);",
          "    return 0;",
          "}",
          "",
          "/* ---------------------------- Utility Functions --------------------------- */",
          "void display(node *root) {",
          "    if (root == NULL) {",
          "        return;",
          "    }",
          "",
          "    string str = \"\";",
          "    str += root->left == NULL ? \".\" : to_string((root->left)->data) + \"\";",
          "    str += \" <- \" + to_string(root->data) + \" -> \";",
          "    str += root->right == NULL ? \".\" : to_string((root->right)->data) + \"\";",
          "    cout << str << endl;",
          "",
          "    display(root->left);",
          "    display(root->right);",
          "}",
          "",
          "node *construct() {",
          "    int n;",
          "    cin >> n;",
          "    string s;",
          "    vector<int> arr;",
          "    for (int i = 0; i < n; ++i) {",
          "        cin >> s;",
          "        if (s == \"n\")",
          "            arr.push_back(-1);",
          "        else",
          "            arr.push_back(stoi(s));",
          "    }",
          "",
          "    node *root = new node(arr[0], NULL, NULL);",
          "    Pair rtp(root, 1);",
          "",
          "    stack<Pair> st;",
          "    st.push(rtp);",
          "",
          "    int idx = 0;",
          "    while (st.size() > 0) {",
          "        Pair top = st.top();",
          "        if (top.state == 1) {",
          "            idx++;",
          "",
          "            st.pop();",
          "            top.state++;",
          "            st.push(top);",
          "",
          "            if (arr[idx] != -1) {",
          "                (top.root)->left = new node(arr[idx], NULL, NULL);",
          "                Pair lp((top.root)->left, 1);",
          "                st.push(lp);",
          "            } else {",
          "                (top.root)->left = NULL;",
          "            }",
          "        } else if (top.state == 2) {",
          "            idx++;",
          "",
          "            st.pop();",
          "            top.state++;",
          "            st.push(top);",
          "",
          "            if (arr[idx] != -1) {",
          "                (top.root)->right = new node(arr[idx], NULL, NULL);",
          "                Pair rp((top.root)->right, 1);",
          "                st.push(rp);",
          "            } else {",
          "                (top.root)->right = NULL;",
          "            }",
          "        } else {",
          "            st.pop();",
          "        }",
          "    }",
          "    return root;",
          "}",
          ""
        ],
        "description": "Pep Coding Template for Trees (Foundation Class) construct from inorder and display like it is"
      },
      "Template used for showing sorting and swapping processes": {
        "prefix": "sorting template",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "",
          "void swap(int *, int, int);",
          "bool isSmaller(int *, int, int);",
          "void print(int *, int);",
          "",
          "/* -------------------------------- main code ------------------------------- */",
          "$1",
          "/* -------------------------------- template -------------------------------- */",
          "",
          "int main() {",
          "    int n;",
          "    cin >> n;",
          "    int arr[n];",
          "    for(int i=0; i<n; ++i) cin >> arr[i];",
          "    print(arr, n);",
          "    return 0;",
          "}",
          "",
          "void swap(int *arr, int i, int j) {",
          "    cout << \"Swapping \" << arr[i] << \" and \" << arr[j] << endl;",
          "    int temp = arr[i];",
          "    arr[i] = arr[j];",
          "    arr[j] = temp;",
          "}",
          "",
          "bool isSmaller(int *arr, int i, int j) {",
          "    cout << \"Comparing \" << arr[i] << \" and \" << arr[j] << endl;",
          "    if (arr[i] < arr[j]) {",
          "        return true;",
          "    } else {",
          "        return false;",
          "    }",
          "}",
          "",
          "void print(int *arr, int n) {",
          "    for (int i = 0; i < n; ++i) {",
          "        cout << arr[i] << endl;",
          "    }",
          "}",
          ""
        ],
        "description": "Template used for showing sorting and swapping processes"
      },
      "basic template": {
        "prefix": "basic",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "",
          "int main() {",
          "    ${1}",
          "    return 0;",
          "}"
        ],
        "description": ""
      },
      "basic template with debugger": {
        "prefix": "basic_deb",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "#define deb(x) cout << #x << \"->\" << x << endl;",
          "#define print(x)                          \\",
          "    for (auto &x_ : x) cout << x_ << \" \"; \\",
          "    cout << endl;",
          "",
          "int main() {",
          "${1:#ifndef ONLINE_JUDGE",
          "    freopen(\"input.txt\", \"r\", stdin);",
          "    freopen(\"output.txt\", \"w\", stdout);",
          "#endif}",
          "    return 0;",
          "}"
        ],
        "description": ""
      },
      "": {
        "prefix": "pep_found_ll",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "",
          "class Node {",
          "   public:",
          "    int data;",
          "    Node *next;",
          "",
          "    Node() {",
          "        this->data = 0;",
          "        this->next = NULL;",
          "    }",
          "",
          "    Node(int data) {",
          "        this->data = data;",
          "        this->next = NULL;",
          "    }",
          "};",
          "",
          "class LinkedList {",
          "   public:",
          "    Node *head;",
          "    Node *tail;",
          "    int size;",
          "",
          "    LinkedList() {",
          "        head = NULL;",
          "        tail = NULL;",
          "        size = 0;",
          "    }",
          "",
          "    void addLast(int data) {",
          "        Node *temp = new Node(data);",
          "        temp->next = NULL;",
          "        if (head == NULL && tail == NULL) {",
          "            head = tail = temp;",
          "        } else {",
          "            tail->next = temp;",
          "            tail = temp;",
          "        }",
          "        ++size;",
          "    }",
          "",
          "    void display() {",
          "        Node *p = head;",
          "        while (p != NULL) {",
          "            cout << p->data << \" \";",
          "            p = p->next;",
          "        }",
          "        cout << endl;",
          "    }",
          "};",
          "",
          "void construct(LinkedList &ll) {",
          "    while (true) {",
         
                  "\t\tstring command;",
                  "\t\tcin >> command;",
                  "\t\tif (command == \"quit\") {",
                      "\t\t\tbreak;",
                  "\t\t}",
                  "\t\tint number; ",
          "    }",
          "}",
          "",
          "/* -------------------------------- Main Code ------------------------------- */",
          "$1",
          "/* -------------------------------------------------------------------------- */",
          "int main() {",
          "    LinkedList ll;",
          "    construct(ll);",
          "    ll.display();",
          "    return 0;",
          "}",
          ""
        ],
        "description": ""
      },
      //! graph input
      "competitive graph input": {
        "prefix": "ip_graph",
        "body": [
          "#include <bits/stdc++.h>",
          "using namespace std;",
          "",
          "const int N = (int)1e5;",
          "vector<int> graph[N];",
          "int n, m;",
          "",
          "int main() {",
          "    cin >> n >> m;",
          "    for (int i = 0; i < m; ++i) {",
          "        int u, v;",
          "        cin >> u >> v;",
          "        graph[u].push_back(v);",
          "        graph[v].push_back(u);",
          "    }",
          "    ${1}",
          "}"
        ],
        "description": ""
      }
}